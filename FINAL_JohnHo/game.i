# 1 "game.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "game.c"
# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 1 3
# 10 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 3
# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/ieeefp.h" 1 3
# 11 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 2 3
# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/_ansi.h" 1 3
# 15 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/_ansi.h" 3
# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/newlib.h" 1 3
# 16 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/_ansi.h" 2 3
# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/config.h" 1 3



# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/ieeefp.h" 1 3
# 5 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/config.h" 2 3
# 17 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/_ansi.h" 2 3
# 12 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 2 3



# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/include/stddef.h" 1 3 4
# 211 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/include/stddef.h" 3 4
typedef unsigned int size_t;
# 323 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/include/stddef.h" 3 4
typedef unsigned int wchar_t;
# 16 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 2 3

# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 1 3
# 13 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 3
# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/_ansi.h" 1 3
# 14 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 2 3
# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/_types.h" 1 3
# 12 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/_types.h" 3
# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/_types.h" 1 3






# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/_default_types.h" 1 3
# 26 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/_default_types.h" 3
typedef signed char __int8_t ;
typedef unsigned char __uint8_t ;
# 36 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/_default_types.h" 3
typedef signed short __int16_t;
typedef unsigned short __uint16_t;
# 46 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/_default_types.h" 3
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
# 58 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/_default_types.h" 3
typedef signed int __int32_t;
typedef unsigned int __uint32_t;
# 76 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/_default_types.h" 3
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
# 99 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/_default_types.h" 3
typedef signed long long __int64_t;
typedef unsigned long long __uint64_t;
# 8 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/_types.h" 2 3
# 13 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/_types.h" 2 3
# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/lock.h" 1 3





typedef int _LOCK_T;
typedef int _LOCK_RECURSIVE_T;
# 14 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/_types.h" 2 3


typedef long _off_t;







typedef int __dev_t;




typedef unsigned short __uid_t;


typedef unsigned short __gid_t;



__extension__ typedef long long _off64_t;







typedef long _fpos_t;
# 56 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/_types.h" 3
typedef int _ssize_t;






# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/include/stddef.h" 1 3 4
# 352 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 64 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/_types.h" 2 3



typedef struct
{
  int __count;
  union
  {
    wint_t __wch;
    unsigned char __wchb[4];
  } __value;
} _mbstate_t;



typedef _LOCK_RECURSIVE_T _flock_t;




typedef void *_iconv_t;
# 15 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 2 3






typedef unsigned long __ULong;
# 37 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 3
struct _reent;






struct _Bigint
{
  struct _Bigint *_next;
  int _k, _maxwds, _sign, _wds;
  __ULong _x[1];
};


struct __tm
{
  int __tm_sec;
  int __tm_min;
  int __tm_hour;
  int __tm_mday;
  int __tm_mon;
  int __tm_year;
  int __tm_wday;
  int __tm_yday;
  int __tm_isdst;
};







struct _on_exit_args {
 void * _fnargs[32];
 void * _dso_handle[32];

 __ULong _fntypes;


 __ULong _is_cxa;
};
# 89 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 3
struct _atexit {
 struct _atexit *_next;
 int _ind;

 void (*_fns[32])(void);
        struct _on_exit_args _on_exit_args;
};
# 105 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 3
struct __sbuf {
 unsigned char *_base;
 int _size;
};
# 169 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 3
struct __sFILE {
  unsigned char *_p;
  int _r;
  int _w;
  short _flags;
  short _file;
  struct __sbuf _bf;
  int _lbfsize;






  void * _cookie;

  int (* _read) (struct _reent *, void *, char *, int)
                     ;
  int (* _write) (struct _reent *, void *, const char *, int)
                            ;
  _fpos_t (* _seek) (struct _reent *, void *, _fpos_t, int);
  int (* _close) (struct _reent *, void *);


  struct __sbuf _ub;
  unsigned char *_up;
  int _ur;


  unsigned char _ubuf[3];
  unsigned char _nbuf[1];


  struct __sbuf _lb;


  int _blksize;
  int _offset;


  struct _reent *_data;



  _flock_t _lock;

  _mbstate_t _mbstate;
  int _flags2;
};
# 273 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 3
typedef struct __sFILE __FILE;



struct _glue
{
  struct _glue *_next;
  int _niobs;
  __FILE *_iobs;
};
# 305 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 3
struct _rand48 {
  unsigned short _seed[3];
  unsigned short _mult[3];
  unsigned short _add;




};
# 579 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 3
struct _reent
{
  int _errno;




  __FILE *_stdin, *_stdout, *_stderr;

  int _inc;
  char _emergency[25];

  int _current_category;
  const char *_current_locale;

  int __sdidinit;

  void (* __cleanup) (struct _reent *);


  struct _Bigint *_result;
  int _result_k;
  struct _Bigint *_p5s;
  struct _Bigint **_freelist;


  int _cvtlen;
  char *_cvtbuf;

  union
    {
      struct
        {
          unsigned int _unused_rand;
          char * _strtok_last;
          char _asctime_buf[26];
          struct __tm _localtime_buf;
          int _gamma_signgam;
          __extension__ unsigned long long _rand_next;
          struct _rand48 _r48;
          _mbstate_t _mblen_state;
          _mbstate_t _mbtowc_state;
          _mbstate_t _wctomb_state;
          char _l64a_buf[8];
          char _signal_buf[24];
          int _getdate_err;
          _mbstate_t _mbrlen_state;
          _mbstate_t _mbrtowc_state;
          _mbstate_t _mbsrtowcs_state;
          _mbstate_t _wcrtomb_state;
          _mbstate_t _wcsrtombs_state;
   int _h_errno;
        } _reent;



      struct
        {

          unsigned char * _nextf[30];
          unsigned int _nmalloc[30];
        } _unused;
    } _new;


  struct _atexit *_atexit;
  struct _atexit _atexit0;


  void (**(_sig_func))(int);




  struct _glue __sglue;
  __FILE __sf[3];
};
# 817 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 3
extern struct _reent *_impure_ptr ;
extern struct _reent *const _global_impure_ptr ;

void _reclaim_reent (struct _reent *);
# 18 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 2 3
# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/stdlib.h" 1 3
# 19 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 2 3
# 27 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 3


typedef struct
{
  int quot;
  int rem;
} div_t;

typedef struct
{
  long quot;
  long rem;
} ldiv_t;
# 58 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 3
extern int __mb_cur_max;



void abort (void) __attribute__ ((noreturn));
int abs (int);
int atexit (void (*__func)(void));
double atof (const char *__nptr);



int atoi (const char *__nptr);
int _atoi_r (struct _reent *, const char *__nptr);
long atol (const char *__nptr);
long _atol_r (struct _reent *, const char *__nptr);
void * bsearch (const void * __key, const void * __base, size_t __nmemb, size_t __size, int (* _compar) (const void *, const void *))



                                                         ;
void * calloc (size_t __nmemb, size_t __size) ;
div_t div (int __numer, int __denom);
void exit (int __status) __attribute__ ((noreturn));
void free (void *) ;
char * getenv (const char *__string);
char * _getenv_r (struct _reent *, const char *__string);
char * _findenv (const char *, int *);
char * _findenv_r (struct _reent *, const char *, int *);
long labs (long);
ldiv_t ldiv (long __numer, long __denom);
void * malloc (size_t __size) ;
int mblen (const char *, size_t);
int _mblen_r (struct _reent *, const char *, size_t, _mbstate_t *);
int mbtowc (wchar_t *, const char *, size_t);
int _mbtowc_r (struct _reent *, wchar_t *, const char *, size_t, _mbstate_t *);
int wctomb (char *, wchar_t);
int _wctomb_r (struct _reent *, char *, wchar_t, _mbstate_t *);
size_t mbstowcs (wchar_t *, const char *, size_t);
size_t _mbstowcs_r (struct _reent *, wchar_t *, const char *, size_t, _mbstate_t *);
size_t wcstombs (char *, const wchar_t *, size_t);
size_t _wcstombs_r (struct _reent *, char *, const wchar_t *, size_t, _mbstate_t *);
# 111 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 3
void qsort (void * __base, size_t __nmemb, size_t __size, int(*_compar)(const void *, const void *));
int rand (void);
void * realloc (void * __r, size_t __size) ;



void srand (unsigned __seed);
double strtod (const char *__n, char **__end_PTR);
double _strtod_r (struct _reent *,const char *__n, char **__end_PTR);
float strtof (const char *__n, char **__end_PTR);






long strtol (const char *__n, char **__end_PTR, int __base);
long _strtol_r (struct _reent *,const char *__n, char **__end_PTR, int __base);
unsigned long strtoul (const char *__n, char **__end_PTR, int __base);
unsigned long _strtoul_r (struct _reent *,const char *__n, char **__end_PTR, int __base);

int system (const char *__string);
# 198 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 3
char * _dtoa_r (struct _reent *, double, int, int, int *, int*, char**);

void * _malloc_r (struct _reent *, size_t) ;
void * _calloc_r (struct _reent *, size_t, size_t) ;
void _free_r (struct _reent *, void *) ;
void * _realloc_r (struct _reent *, void *, size_t) ;
void _mstats_r (struct _reent *, char *);

int _system_r (struct _reent *, const char *);

void __eprintf (const char *, const char *, unsigned int, const char *);



extern long double strtold (const char *, char **);
extern long double wcstold (const wchar_t *, wchar_t **);



# 2 "game.c" 2
# 1 "myLib.h" 1




typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned int u32;
# 64 "myLib.h"
extern unsigned short *videoBuffer;
# 85 "myLib.h"
typedef struct {
 u16 tileimg[8192];
} charblock;


typedef struct {
 u16 tilemap[1024];
} screenblock;



void setPixel3(int row, int col, unsigned short color);
void drawRect3(int row, int col, int height, int width, volatile unsigned short color);
void fillScreen3(volatile unsigned short color);
void drawImage3(int row, int col, int height, int width, const unsigned short *image);
void drawFullscreenImage3(const unsigned short *image);


void setPixel4(int row, int col, unsigned char colorIndex);
void drawRect4(int row, int col, int height, int width, volatile unsigned char colorIndex);
void fillScreen4(volatile unsigned char colorIndex);
void drawImage4(int row, int col, int height, int width, const unsigned short *image);
void drawFullscreenImage4(const unsigned short *image);


void waitForVBlank();
void flipPage();
void loadPalette(const unsigned short * palette);





typedef struct {
    unsigned short attr0;
    unsigned short attr1;
    unsigned short attr2;
    unsigned short fill;
} OBJ_ATTR;



extern OBJ_ATTR shadowOAM[];
# 158 "myLib.h"
void hideSprites();
# 183 "myLib.h"
extern unsigned short oldButtons;
extern unsigned short buttons;
# 194 "myLib.h"
typedef volatile struct {
    volatile const void *src;
    volatile void *dst;
    volatile unsigned int cnt;
} DMA;


extern DMA *dma;
# 322 "myLib.h"
typedef struct
{
    int row;
    int col;
    int rdel;
    int cdel;
    int size;
    u16 color;
    int AI_STATE;
} MOVOBJ;

void DMANow(int channel, volatile const void *src, volatile void *dst, unsigned int cnt);




int collision(int rowA, int colA, int heightA, int widthA, int rowB, int colB, int heightB, int widthB);
# 3 "game.c" 2
# 1 "game.h" 1

typedef struct {
    int screenRow;
    int screenCol;
    int worldRow;
    int worldCol;
    int rdel;
    int cdel;
    int width;
    int height;
    int aniCounter;
    int aniState;
    int prevAniState;
    int curFrame;
    int numFrames;
    int active;
    int index;
    int hide;
    int dieCounter;
    int hits;
} ANISPRITE;


typedef struct {
    int screenRow;
    int screenCol;
    int worldRow;
    int worldCol;
 int rdel;
 int cdel;
 int height;
 int width;
 int active;
 int index;
    int direction;
    int range;
    int hide;
    int type;
} BULLET;

typedef struct {
    int screenRow;
    int screenCol;
    int hide;
    int index;
} LIFE;


typedef struct{
    const unsigned char* data;
    int length;
    int frequency;
    int isPlaying;
    int loops;
    int duration;
    int priority;
    int vbCount;
}SOUND;

extern SOUND soundA;
extern SOUND soundB;
# 72 "game.h"
extern ANISPRITE player;
extern ANISPRITE king;
extern LIFE hearts[3];

extern BULLET bullets[1];
extern BULLET cheatBullets[10];
extern BULLET enemyBullets[5];
extern BULLET bossBullets[5];
extern int enemiesRemaining;

extern int lives;
extern int direction;
extern int cheat;
extern int isBoss;


extern int hOff;
extern int vOff;


void initGame();
void updateGame();
void drawGame();

void initBossGame();
void initBoss();
void drawBoss();
void updateBoss();
void drawBossBullet(BULLET *);

void goToLose();
void initLives();
void updateLives();
void drawLives(LIFE *);

void initPlayer();
void updatePlayer();
void drawPlayer();

void initEnemies();
void updateEnemies(ANISPRITE *);
void drawEnemies(ANISPRITE *);

void initBullets();
void fireBullet();
void updateBullet(BULLET *);
void drawBullet(BULLET *);
void drawEnemyBullet();
void fireEnemyBullet();


void setupSounds();
void playSoundA( const unsigned char* sound, int length, int frequency, int loops);
void playSoundB( const unsigned char* sound, int length, int frequency, int loops);
void pauseSound();
void muteSound();
void unmuteSound();
void stopSound();

void setupInterrupts();
void interruptHandler();
# 4 "game.c" 2
# 1 "slash.h" 1
# 20 "slash.h"
extern const unsigned char slash_c1[13495];
extern const unsigned char slash_c2[13495];
# 5 "game.c" 2
# 1 "fireball.h" 1
# 20 "fireball.h"
extern const unsigned char fireball[8976];
# 6 "game.c" 2
# 1 "collisionmap.h" 1
# 20 "collisionmap.h"
extern const unsigned short collisionmapBitmap[262144];
# 7 "game.c" 2
# 1 "collisionmap2.h" 1
# 20 "collisionmap2.h"
extern const unsigned short collisionmap2Bitmap[262144];
# 8 "game.c" 2
# 1 "pig.h" 1
# 20 "pig.h"
extern const unsigned char pig[6990];
# 9 "game.c" 2
# 1 "hurt.h" 1
# 20 "hurt.h"
extern const unsigned char hurt[3912];
# 10 "game.c" 2
# 1 "slimehit.h" 1
# 20 "slimehit.h"
extern const unsigned char slimehit[6881];
# 11 "game.c" 2
# 1 "slimedeath.h" 1
# 20 "slimedeath.h"
extern const unsigned char slimedeath[15368];
# 12 "game.c" 2


BULLET bullets[1];
BULLET enemyBullets[5];
BULLET bossBullets[5];
BULLET cheatBullets[10];

ANISPRITE enemies[5];
ANISPRITE king;
LIFE hearts[3];

int enemiesRemaining;
int lives;


int hOff = 0;
int vOff = 0;


int count = 0;
int forward = 1;

ANISPRITE player;
ANISPRITE enemy1;

enum {PLAYERFRONT, PLAYERBACK, PLAYERLEFT, PLAYERRIGHT, PLAYERIDLE};
enum {ENEMYFRONT, ENEMYFIRE, ENEMYDIE, ENEMYIDLE};



void initGame() {

 initPlayer();
 initBullets();
 initEnemies();
 initLives();


 enemiesRemaining = 5;


 lives = 3;
 king.hide = 1;
 isBoss = 0;


    (*(volatile unsigned short *)0x04000012) = vOff;
    (*(volatile unsigned short *)0x04000010) = hOff;
}



void updateGame() {

 updatePlayer();
 updateLives();



 if(cheat) {

  for (int i = 0; i < 10; i++) {
   updateBullet(&cheatBullets[i]);
  }

 } else {

  for (int i = 0; i < 1; i++) {
   updateBullet(&bullets[i]);
  }
 }

 if(!isBoss) {

  for (int i = 0; i < 5; i++) {
   updateBullet(&enemyBullets[i]);
  }

  for (int i = 0; i < 5; i++) {
   updateEnemies(&enemies[i]);

  }
 } else {

  updateEnemies(&king);


  for (int i = 0; i < 5; i++) {
   updateBullet(&bossBullets[i]);

  }
 }



}


void drawGame() {

 drawPlayer();


 for (int i = 0; i < 3; i++){
  drawLives(&hearts[i]);
 }


 if(cheat) {

  for (int i = 0; i < 10; i++){

   drawBullet(&cheatBullets[i]);
  }

 } else {

  for (int i = 0; i < 1; i++){

   drawBullet(&bullets[i]);
  }
 }


 if(!isBoss) {
  for (int i = 0; i < 5; i++){
   drawEnemyBullet(&enemyBullets[i]);
  }


  for (int i = 0; i < 5; i++) {
   drawEnemies(&enemies[i]);
  }
 } else {

  drawBoss();

  for (int i = 0; i < 5; i++) {
   drawBossBullet(&bossBullets[i]);
  }
 }
 DMANow(3, shadowOAM, ((OBJ_ATTR*)(0x7000000)), 128*4);

    (*(volatile unsigned short *)0x04000010) = hOff;
    (*(volatile unsigned short *)0x04000012) = vOff;
}



void initBossGame() {



 enemiesRemaining = 1;
 isBoss = 1;
 hOff = 0;
 vOff = 0;

 initPlayer();
 initBoss();
 initBullets();

}

void initBoss() {

 king.width = 50;
    king.height = 50;
    king.rdel = 1;
    king.cdel = 1;
    king.worldRow = 250;
    king.worldCol = 200;
    king.aniCounter = 0;
    king.curFrame = 0;
    king.numFrames = 2;
    king.active = 1;
    king.index = 40;
    king.aniState = 0;
    king.hide = 0;
    king.hits = 10;
}




void initPlayer() {

    player.width = 24;
    player.height = 24;
    player.rdel = 1;
    player.cdel = 1;
    player.worldRow = 160/2-player.width/2 + vOff;
    player.worldCol = 240/2-player.height/2 + hOff;
    player.aniCounter = 0;
    player.curFrame = 0;
    player.numFrames = 2;
    player.active = 1;
    player.index = 0;
    player.aniState = PLAYERFRONT;
    player.dieCounter = 0;
}

void initLives() {

 for(int i = 0; i < 3; i++) {
  hearts[i].screenRow = 4;
  hearts[i].screenCol = 4 + i*20;
  hearts[i].hide = 0;
  hearts[i].index = 27 + i;
 }

}


void initEnemies() {

 for (int i = 0; i < 5; i++) {

  enemies[i].width = 24;
  enemies[i].height = 24;
  if(i == 0) {
      enemies[i].worldRow = 64;
      enemies[i].worldCol = 415;
     } else if (i == 1) {
      enemies[i].worldRow = 310;
      enemies[i].worldCol = 190;
     } else if (i == 2) {
      enemies[i].worldRow = 440;
      enemies[i].worldCol = 130;
     } else if (i == 3) {
      enemies[i].worldRow = 432;
      enemies[i].worldCol = 415;
     } else if (i == 4) {
      enemies[i].worldRow = 280;
      enemies[i].worldCol = 415;
     }
     enemies[i].rdel = 1;
     enemies[i].cdel = 1;
     enemies[i].aniCounter = 0;
     enemies[i].curFrame = 0;
     enemies[i].numFrames = 2;
     enemies[i].active = 1;
     enemies[i].index = 1*i + 11;
     enemies[i].aniState = ENEMYFRONT;
     enemies[i].dieCounter = 0;
 }
}


void initBullets() {

 if(cheat) {

  for (int i = 0; i < 10; i++) {

   cheatBullets[i].height = 24;
   cheatBullets[i].width = 24;
      cheatBullets[i].screenRow = 0;
      cheatBullets[i].screenCol = 0;
      cheatBullets[i].worldRow = 0;
      cheatBullets[i].worldCol = 0;
   cheatBullets[i].rdel = 2;
         cheatBullets[i].cdel = 2;
   cheatBullets[i].active = 0;
   cheatBullets[i].index = i*1 + 30;
   cheatBullets[i].direction = 0;
   cheatBullets[i].range = 0;
   cheatBullets[i].hide = 1;
   cheatBullets[i].type = 0;
  }

 } else {


  for (int i = 0; i < 1; i++) {

   bullets[i].height = 24;
   bullets[i].width = 24;
      bullets[i].screenRow = 0;
      bullets[i].screenCol = 0;
      bullets[i].worldRow = 0;
      bullets[i].worldCol = 0;
   bullets[i].rdel = 2;
         bullets[i].cdel = 2;
   bullets[i].active = 0;
   bullets[i].index = i+1;
   bullets[i].direction = 0;
   bullets[i].range = 0;
   bullets[i].hide = 1;
   bullets[i].type = 0;
  }
 }


 if(!isBoss) {

  for (int i = 0; i < 5; i++) {

   enemyBullets[i].height = 24;
   enemyBullets[i].width = 24;
      enemyBullets[i].screenRow = 0;
      enemyBullets[i].screenCol = 0;
      enemyBullets[i].worldRow = 0;
      enemyBullets[i].worldCol = 0;
   enemyBullets[i].rdel = 2;
         enemyBullets[i].cdel = 2;
   enemyBullets[i].active = 0;
   enemyBullets[i].index = i*1 + 20;
   enemyBullets[i].direction = 0;
   enemyBullets[i].range = 0;
   enemyBullets[i].hide = 1;
   enemyBullets[i].type = 1;
  }
 } else {

  for (int i = 0; i < 5; i++) {

   bossBullets[i].height = 50;
   bossBullets[i].width = 50;
      bossBullets[i].screenRow = 0;
      bossBullets[i].screenCol = 0;
      bossBullets[i].worldRow = 0;
      bossBullets[i].worldCol = 0;
   bossBullets[i].rdel = 2;
         bossBullets[i].cdel = 2;
   bossBullets[i].active = 0;
   bossBullets[i].index = i*1 + 45;
   bossBullets[i].direction = 0;
   bossBullets[i].range = 0;
   bossBullets[i].hide = 1;
   bossBullets[i].type = 2;
   if(i == 0 || i == 2 || i == 4){
    bossBullets[i].direction = 0;
   }
   else{
    bossBullets[i].direction = 1;
   }
  }



 }


}

void updateLives() {

 if(lives == 2) {
  hearts[2].hide = 1;
 }

 if(lives == 1) {
  hearts[1].hide = 1;
 }

}


void updatePlayer() {

        player.prevAniState = player.aniState;
        player.aniState = PLAYERIDLE;



     player.screenCol = player.worldCol - hOff;
  player.screenRow = player.worldRow - vOff;




        if(player.aniCounter % 20 == 0) {
            if (player.curFrame < 1) {
                player.curFrame++;
            }
            else {
                player.curFrame = 0;
            }

        }



         if((~((*(volatile unsigned short *)0x04000130)) & ((1<<6)))) {

          player.aniState = PLAYERBACK;

          if( player.screenRow >= 0 && collisionmapBitmap[((player.worldRow - 1)*(512)+(player.worldCol))]
    && collisionmapBitmap[((player.worldRow - 1)*(512)+(player.worldCol + player.width - 1))]) {

           if(player.worldRow - 80 + 16 <= 0) {
      player.worldRow--;
     } else if (player.worldRow + 80 + 16 > 512 ) {
      player.worldRow--;
     } else {
      vOff--;
      player.worldRow--;
        }
    }
         }
         if((~((*(volatile unsigned short *)0x04000130)) & ((1<<7)))){
          player.aniState = PLAYERFRONT;
          if( player.screenRow + player.height < 160 && collisionmapBitmap[((player.worldRow + player.height)*(512)+(player.worldCol))]
    && collisionmapBitmap[((player.worldRow + player.height)*(512)+(player.worldCol + player.width - 1))]) {

     if(player.worldRow - 80 + 16 <= 0) {
      player.worldRow++;
     } else if (player.worldRow + 80 + 16 > 512 ) {
      player.worldRow++;
     } else {
      vOff++;
      player.worldRow++;
        }
    }
         }
         if((~((*(volatile unsigned short *)0x04000130)) & ((1<<5)))) {
     player.aniState = PLAYERLEFT;
          if( player.screenCol >= 0 && collisionmapBitmap[((player.worldRow)*(512)+(player.worldCol - 1))]
    && collisionmapBitmap[((player.worldRow + player.height - 1)*(512)+(player.worldCol - 1))]) {

     if(player.worldCol - 120 + 16 < 0){
      player.worldCol--;
     }
     else if (player.worldCol + 120 + 16 >= 512){
      player.worldCol--;
     }
     else {
      hOff--;
      player.worldCol--;
     }
    }
         }
         if((~((*(volatile unsigned short *)0x04000130)) & ((1<<4)))) {
          player.aniState = PLAYERRIGHT;
          if( player.screenCol + player.width < 240 && collisionmapBitmap[((player.worldRow)*(512)+(player.worldCol + player.width))]
    && collisionmapBitmap[((player.worldRow + player.height - 1)*(512)+(player.worldCol + player.width))]) {

     if(player.worldCol - 120 + 16 < 0){
      player.worldCol++;
     }
     else if (player.worldCol + 120 + 16 >= 512){
      player.worldCol++;
     }
     else {
      hOff++;
      player.worldCol++;
     }
    }
   }



        if (player.aniState == PLAYERIDLE) {
            player.curFrame = 0;
            player.aniState = player.prevAniState;
        }
        else {
            player.aniCounter++;
        }




 if ((!(~(oldButtons)&((1<<0))) && (~buttons & ((1<<0))))) {

  fireBullet();
 }

}




void updateEnemies(ANISPRITE * e) {


 if(e->aniState == ENEMYDIE ) {
  e->dieCounter++;
  if(e->dieCounter == 30) {
   e->active = 0;
   enemiesRemaining--;
  }
 }

 if(e->active && e->aniState != ENEMYDIE) {

     e->hide = (e->screenRow < -e->height || e->screenRow > 160) ? 1 : 0;


        e->prevAniState = e->aniState;
        e->aniState = ENEMYIDLE;


        if(e->aniCounter % 50 == 0 && e->aniState != ENEMYDIE) {
            if (e->curFrame < 1) {
                e->curFrame++;
                fireEnemyBullet();
            }
            else {
                e->curFrame = 0;
            }

        }


        if(cheat) {

      for(int i = 0; i < 10; i++) {
       if(collision(e->worldRow, e->worldCol, e->height, e->width,
        cheatBullets[i].worldRow, cheatBullets[i].worldCol, cheatBullets[i].height, cheatBullets[i].width) && cheatBullets[i].active) {
         e->aniState = ENEMYDIE;
         e->curFrame = ENEMYDIE;
         cheatBullets[i].active = 0;
         if(!isBoss) {
          playSoundB(pig, 6990, 11025, 0);

         } else if (!e->hide){
          e->hits--;
          playSoundB(slimehit, 6881, 11025, 0);
          if(e->hits == 0){
           playSoundB(slimedeath, 15368, 11025, 0);
           e->active = 0;
          } else {
           e->aniState = ENEMYFRONT;
          }

         }


       }

      }

        } else {

      for(int i = 0; i < 1; i++) {
       if(collision(e->worldRow, e->worldCol, e->height, e->width,
        bullets[i].worldRow, bullets[i].worldCol, bullets[i].height, bullets[i].width) && bullets[i].active) {
         e->aniState = ENEMYDIE;
         e->curFrame = ENEMYDIE;
         bullets[i].active = 0;
         if(!isBoss) {
          playSoundB(pig, 6990, 11025, 0);

         } else if (!e->hide){
          e->hits--;
          playSoundB(slimehit, 6881, 11025, 0);
          if(e->hits == 0){
           playSoundB(slimedeath, 15368, 11025, 0);
           e->active = 0;

          } else {
           e->aniState = ENEMYFRONT;
          }

         }


       }

      }
  }



  if (collision(e->worldRow, e->worldCol, e->height, e->width,
   player.worldRow, player.worldCol, player.height, player.width)) {
   lives--;
   e->active = 0;
   playSoundB(hurt, 3912, 11025, 0);
   if(isBoss) {
    lives = 0;
   }
   if(lives == 0) {
    goToLose();
   }
   enemiesRemaining--;
  }


  if(!isBoss) {
   if (count <= 144 && forward && e->aniState != ENEMYDIE) {
    e->aniState = ENEMYFIRE;
    e->worldCol--;
    count++;
    if(count == 144){
     count = 0;
     forward = 0;
    }
   } else if (count <= 144 && !forward && e->aniState != ENEMYDIE){
    e->aniState = ENEMYFIRE;
    e->worldCol++;
    count++;
    if(count == 144){
     count = 0;
     forward = 1;
    }
   }
  } else {

   if (count <= 120 && forward && e->aniState != ENEMYDIE) {
    e->aniState = ENEMYFIRE;
    e->worldRow--;
    count++;
    if(count == 120){
     count = 0;
     forward = 0;
    }
   } else if (count <= 120 && !forward && e->aniState != ENEMYDIE){
    e->aniState = ENEMYFIRE;
    e->worldRow++;
    count++;
    if(count == 120){
     count = 0;
     forward = 1;
    }
   }


  }


        if (e->aniState == ENEMYIDLE) {
            e->curFrame = 0;
            e->aniState = e->prevAniState;
        }
        else {
            e->aniCounter++;
        }

 }

     e->screenCol = e->worldCol - hOff;
     e->screenRow = e->worldRow - vOff;


}





void updateBullet(BULLET* b) {



 if (b->active) {


   if(!cheat && b->range == 50) {
    b->active = 0;
    b->range = 0;
    b->hide = 1;
   } else if (cheat && b->range == 75) {
    b->active = 0;
    b->range = 0;
    b->hide = 1;
   }


   if (b->type == 1){

             b->worldCol -= b->cdel;
             b->range++;


             if (cheat) {
        for(int i = 0; i < 10; i++) {
      if(collision(b->worldRow, b->worldCol, b->height, b->width,
            cheatBullets[i].worldRow, cheatBullets[i].worldCol, cheatBullets[i].height, cheatBullets[i].width)
       && cheatBullets[i].active) {

       b->active = 0;
       b->hide = 0;
       b->range = 0;

       cheatBullets[i].active = 0;
       cheatBullets[i].hide = 1;
       cheatBullets[i].range = 0;
      }
     }

             } else {
        for(int i = 0; i < 1; i++) {
      if(collision(b->worldRow, b->worldCol, b->height, b->width,
            bullets[i].worldRow, bullets[i].worldCol, bullets[i].height, bullets[i].width)
       && bullets[i].active) {

       b->active = 0;
       b->hide = 0;
       b->range = 0;

       bullets[i].active = 0;
       bullets[i].hide = 1;
       bullets[i].range = 0;
      }
     }
    }


       for(int i = 0; i < 1; i++) {
     if(collision(b->worldRow, b->worldCol, b->height, b->width,
           player.worldRow, player.worldCol, player.height, player.width)) {

      lives--;
      b->active = 0;
      b->hide = 0;
      b->range = 0;
      playSoundB(hurt, 3912, 11025, 0);

      if(lives == 0) {
       goToLose();
      }
     }
    }


   } else if (b->type == 2) {


    if (b->direction == 0) {
     b->worldCol -= b->cdel;
    } else if (b->direction == 1) {
     b->worldCol += b->cdel;
    }

             b->range++;


             if (cheat) {
        for(int i = 0; i < 10; i++) {
      if(collision(b->worldRow, b->worldCol, b->height, b->width,
            cheatBullets[i].worldRow, cheatBullets[i].worldCol, cheatBullets[i].height, cheatBullets[i].width)
       && cheatBullets[i].active) {

       b->active = 0;
       b->hide = 0;
       b->range = 0;

       cheatBullets[i].active = 0;
       cheatBullets[i].hide = 1;
       cheatBullets[i].range = 0;
      }
     }

             } else {
        for(int i = 0; i < 1; i++) {
      if(collision(b->worldRow, b->worldCol, b->height, b->width,
            bullets[i].worldRow, bullets[i].worldCol, bullets[i].height, bullets[i].width)
       && bullets[i].active) {

       b->active = 0;
       b->hide = 0;
       b->range = 0;

       bullets[i].active = 0;
       bullets[i].hide = 1;
       bullets[i].range = 0;
      }
     }
    }


       for(int i = 0; i < 1; i++) {
     if(collision(b->worldRow, b->worldCol, b->height, b->width,
           player.worldRow, player.worldCol, player.height, player.width)) {

      lives--;
      b->active = 0;
      b->hide = 0;
      b->range = 0;
      playSoundB(hurt, 3912, 11025, 0);

      if(lives == 0) {
       goToLose();
      }
     }
    }

   }
             else {

    if (b->direction == 0 && b->screenRow >= 0 && collisionmapBitmap[((b->worldRow - 1)*(512)+(b->worldCol))]
     && collisionmapBitmap[((b->worldRow - 1)*(512)+(b->worldCol + b->width - 1))]) {

              b->worldRow += b->rdel;
              b->range++;
             } else if (b->direction == 1 && b->screenRow + b->height < 160 && collisionmapBitmap[((b->worldRow + b->height)*(512)+(b->worldCol))]
     && collisionmapBitmap[((b->worldRow + b->height)*(512)+(b->worldCol + b->width - 1))]) {

              b->worldRow -= b->rdel;
              b->range++;
             } else if (b->direction == 2 && collisionmapBitmap[((b->worldRow)*(512)+(b->worldCol - 1))]
     && collisionmapBitmap[((b->worldRow + b->height - 1)*(512)+(b->worldCol - 1))]) {

              b->worldCol -= b->cdel;
              b->range++;
             } else if (b->direction == 3 && collisionmapBitmap[((b->worldRow)*(512)+(b->worldCol + b->width))]
     && collisionmapBitmap[((b->worldRow + b->height - 1)*(512)+(b->worldCol + b->width))]) {

              b->worldCol += b->cdel;
              b->range++;
             } else {
              b->active = 0;
              b->hide = 1;
              b->range = 0;
             }
         }

 }

 b->screenCol = b->worldCol - hOff;
 b->screenRow = b->worldRow - vOff;

}






void drawPlayer() {

 shadowOAM[player.index].attr0 = (player.screenRow & 0xFF) | (0<<13) | (0<<14);
 shadowOAM[player.index].attr1 = (player.screenCol & 0x1FF) | (2<<14);
 shadowOAM[player.index].attr2 = ((0)<<12)| ((player.curFrame * 4)*32+(player.aniState * 4));
}


void drawLives(LIFE * h) {
 if (!h->hide) {
  shadowOAM[h->index].attr0 = (h->screenRow & 0xFF) | (0<<13) | (0<<14);
  shadowOAM[h->index].attr1 = (h->screenCol & 0x1FF) | (2<<14);
  shadowOAM[h->index].attr2 = ((0)<<12)| ((8)*32+(16));
 } else {
  shadowOAM[h->index].attr0 |= (2<<8);
 }
}


void drawEnemies(ANISPRITE * e) {

    if (e->active && !e->hide) {
  shadowOAM[e->index].attr0 = (e->screenRow & 0xFF) | (0<<13) | (0<<14);
  shadowOAM[e->index].attr1 = (e->screenCol & 0x1FF) | (2<<14);
  shadowOAM[e->index].attr2 = ((0)<<12)| ((e->curFrame * 4)*32+(20));
 } else {
  shadowOAM[e->index].attr0 |= (2<<8);
 }
}

void drawBoss(){
 if (king.active && !king.hide) {
  shadowOAM[40].attr0 = (king.screenRow & 0xFF) | (0<<13) | (0<<14);
  shadowOAM[40].attr1 = (king.screenCol & 0x1FF) | (3<<14);
  shadowOAM[40].attr2 = ((1)<<12)| ((king.curFrame * 8)*32+(24));
 } else {
  shadowOAM[king.index].attr0 |= (2<<8);
 }
}


void drawBullet(BULLET * b) {

 if(b->active && !b->hide) {
  shadowOAM[b->index].attr0 = (b->screenRow & 0xFF) | (0<<13) | (0<<14);
  shadowOAM[b->index].attr1 = (b->screenCol & 0x1FF) | (2<<14);
  shadowOAM[b->index].attr2 = ((0)<<12)| ((0)*32+(16));
 } else {
  shadowOAM[b->index].attr0 |= (2<<8);
 }
}


void drawEnemyBullet(BULLET * b) {

 if(b->active && !b->hide) {
  shadowOAM[b->index].attr0 = (b->screenRow & 0xFF) | (0<<13) | (0<<14);
  shadowOAM[b->index].attr1 = (b->screenCol & 0x1FF) | (2<<14);
  shadowOAM[b->index].attr2 = ((0)<<12)| ((4)*32+(16));
 } else {
  shadowOAM[b->index].attr0 |= (2<<8);
 }
}



void drawBossBullet(BULLET * b) {

 if(b->active && !b->hide) {
  shadowOAM[b->index].attr0 = (b->screenRow & 0xFF) | (0<<13) | (0<<14);
  shadowOAM[b->index].attr1 = (b->screenCol & 0x1FF) | (3<<14);
  shadowOAM[b->index].attr2 = ((1)<<12)| ((12)*32+(16));
 } else {
  shadowOAM[b->index].attr0 |= (2<<8);
 }
}


void fireBullet() {


 player.curFrame = 2;


 if (cheat) {

  for (int i = 0; i < 10; i++) {
   if (!cheatBullets[i].active) {


    cheatBullets[i].worldRow = player.worldRow;
    cheatBullets[i].worldCol = player.worldCol;

    if (player.aniState == PLAYERFRONT) {
              cheatBullets[i].direction = 0;
             } else if (player.aniState == PLAYERBACK) {
              cheatBullets[i].direction = 1;
             } else if (player.aniState == PLAYERLEFT) {
              cheatBullets[i].direction = 2;
             } else if (player.aniState == PLAYERRIGHT) {
              cheatBullets[i].direction = 3;
             }


    cheatBullets[i].active = 1;
    cheatBullets[i].hide = 0;
    playSoundB(slash_c1, 13495, 11025, 0);


    break;
   }
  }

 } else {

  for (int i = 0; i < 1; i++) {
   if (!bullets[i].active) {


    bullets[i].worldRow = player.worldRow;
    bullets[i].worldCol = player.worldCol;

    if (player.aniState == PLAYERFRONT) {
              bullets[i].direction = 0;
             } else if (player.aniState == PLAYERBACK) {
              bullets[i].direction = 1;
             } else if (player.aniState == PLAYERLEFT) {
              bullets[i].direction = 2;
             } else if (player.aniState == PLAYERRIGHT) {
              bullets[i].direction = 3;
             }


    bullets[i].active = 1;
    bullets[i].hide = 0;
    playSoundB(slash_c1, 13495, 11025, 0);


    break;
   }
  }

 }

}

void fireEnemyBullet() {

 if(!isBoss) {

  for (int i = 0; i < 5; i++) {
   if(enemies[i].active && !enemies[i].hide) {
    if (!enemyBullets[i].active) {


     enemyBullets[i].worldRow = enemies[i].worldRow;
     enemyBullets[i].worldCol = enemies[i].worldCol;


      enemyBullets[i].active = 1;
      enemyBullets[i].hide = 0;
      playSoundB(fireball, 8976, 11025, 0);


     break;
    }
   }
  }

 } else {



  for (int i = 0; i < 5; i++) {
   if(king.active && !king.hide) {
    if (!bossBullets[i].active) {


     bossBullets[i].worldRow = king.worldRow;
     bossBullets[i].worldCol = king.worldCol;


      bossBullets[i].active = 1;
      bossBullets[i].hide = 0;
      playSoundB(fireball, 8976, 11025, 0);


     break;
    }
   }
  }
 }



}
# 1058 "game.c"
void setupSounds()
{
    *(volatile u16 *)0x04000084 = (1<<7);

 *(volatile u16*)0x04000082 = (1<<1) |
                     (1<<2) |
                     (3<<8) |
                     (0<<10) |
                     (1<<11) |
                     (1<<3) |
                     (3<<12) |
                     (1<<14) |
                     (1<<15);

 *(u16*)0x04000080 = 0;
}

void playSoundA( const unsigned char* sound, int length, int frequency, int loops) {
        dma[1].cnt = 0;

        int ticks = (16777216)/frequency;

        DMANow(1, sound, (u16*)0x040000A0, (2 << 21) | (3 << 28) | (1 << 25) | (1 << 26));

        *(volatile unsigned short*)0x4000102 = 0;

        *(volatile unsigned short*)0x4000100 = -ticks;
        *(volatile unsigned short*)0x4000102 = (1<<7);



        soundA.data = sound;
        soundA.length = length;
        soundA.frequency = frequency;
        soundA.priority = 0;
        soundA.duration = (59.727) * length / frequency;
        soundA.vbCount = 0;
        soundA.isPlaying = 1;
        soundA.loops = loops;

}


void playSoundB( const unsigned char* sound, int length, int frequency, int loops) {

        dma[2].cnt = 0;

        int ticks = (16777216)/frequency;

        DMANow(2, sound, (u16*)0x040000A4, (2 << 21) | (3 << 28) | (1 << 25) | (1 << 26));

        *(volatile unsigned short*)0x4000106 = 0;

        *(volatile unsigned short*)0x4000104 = -ticks;
        *(volatile unsigned short*)0x4000106 = (1<<7);



        soundB.data = sound;
        soundB.length = length;
        soundB.frequency = frequency;
        soundB.priority = 0;
        soundB.duration = (59.727) * length / frequency;
        soundB.vbCount = 0;
        soundB.isPlaying = 1;
        soundB.loops = loops;
}

void pauseSound()
{

 soundA.isPlaying = 0;
 soundB.isPlaying = 0;

 *(volatile unsigned short*)0x4000102 = 0;
 *(volatile unsigned short*)0x4000106 = 0;


}

void unpauseSound()
{

 soundA.isPlaying = 1;
 soundB.isPlaying = 1;

 *(volatile unsigned short*)0x4000102 = (1<<7);
 *(volatile unsigned short*)0x4000106 = (1<<7);

}

void stopSound()
{

 soundA.isPlaying = 0;
 soundB.isPlaying = 0;

 *(volatile unsigned short*)0x4000102 = 0;
 *(volatile unsigned short*)0x4000106 = 0;

 dma[1].cnt = 0;
 dma[2].cnt = 0;
}

void setupInterrupts()
{
 *(unsigned short*)0x4000208 = 0;



 *(unsigned int*)0x3007FFC = (unsigned int)interruptHandler;

 *(unsigned short*)0x4000200 |= 1 << 0;
 *(unsigned short*)0x4000004 |= 1 << 3;
 *(unsigned short*)0x4000208 = 1;
}

void interruptHandler()
{
 *(unsigned short*)0x4000208 = 0;
 if(*(volatile unsigned short*)0x4000202 & 1 << 0)
 {



  if (soundA.isPlaying) {
   soundA.vbCount++;
   if(soundA.vbCount >= soundA.duration) {
    if (soundA.loops) {
     playSoundA(soundA.data, soundA.length, soundA.frequency, soundA.loops);
    } else {
     soundA.isPlaying = 0;
     dma[1].cnt = 0;
     *(volatile unsigned short*)0x4000102 = 0;

    }
   }
  }


  if (soundB.isPlaying) {
   soundB.vbCount++;
   if(soundB.vbCount >= soundB.duration) {
    if (soundB.loops) {
     playSoundB(soundB.data, soundB.length, soundB.frequency, soundB.loops);
    } else {
     soundB.isPlaying = 0;
     dma[2].cnt = 0;
     *(volatile unsigned short*)0x4000106 = 0;

    }
   }
  }

  *(volatile unsigned short*)0x4000202 = 1 << 0;
 }

 *(unsigned short*)0x4000208 = 1;
}
